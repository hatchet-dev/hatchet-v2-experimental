// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: concurrency.sql

package sqlcv2

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const concurrencyAdvisoryLock = `-- name: ConcurrencyAdvisoryLock :exec
SELECT pg_advisory_xact_lock($1::bigint)
`

func (q *Queries) ConcurrencyAdvisoryLock(ctx context.Context, db DBTX, key int64) error {
	_, err := db.Exec(ctx, concurrencyAdvisoryLock, key)
	return err
}

const listActiveConcurrencyStrategies = `-- name: ListActiveConcurrencyStrategies :many
SELECT
    DISTINCT ON(tenant_id, step_id, expression) id, workflow_id, step_id, is_active, strategy, expression, tenant_id, max_concurrency
FROM
    v2_step_concurrency
WHERE
    tenant_id = $1::uuid AND
    is_active = TRUE
ORDER BY tenant_id, step_id, expression, id DESC
`

func (q *Queries) ListActiveConcurrencyStrategies(ctx context.Context, db DBTX, tenantid pgtype.UUID) ([]*V2StepConcurrency, error) {
	rows, err := db.Query(ctx, listActiveConcurrencyStrategies, tenantid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*V2StepConcurrency
	for rows.Next() {
		var i V2StepConcurrency
		if err := rows.Scan(
			&i.ID,
			&i.WorkflowID,
			&i.StepID,
			&i.IsActive,
			&i.Strategy,
			&i.Expression,
			&i.TenantID,
			&i.MaxConcurrency,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConcurrencyStrategiesByStepId = `-- name: ListConcurrencyStrategiesByStepId :many
SELECT
    id, workflow_id, step_id, is_active, strategy, expression, tenant_id, max_concurrency
FROM
    v2_step_concurrency
WHERE
    tenant_id = $1::uuid AND
    step_id = ANY($2::uuid[])
ORDER BY 
    id ASC
`

type ListConcurrencyStrategiesByStepIdParams struct {
	Tenantid pgtype.UUID   `json:"tenantid"`
	Stepids  []pgtype.UUID `json:"stepids"`
}

func (q *Queries) ListConcurrencyStrategiesByStepId(ctx context.Context, db DBTX, arg ListConcurrencyStrategiesByStepIdParams) ([]*V2StepConcurrency, error) {
	rows, err := db.Query(ctx, listConcurrencyStrategiesByStepId, arg.Tenantid, arg.Stepids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*V2StepConcurrency
	for rows.Next() {
		var i V2StepConcurrency
		if err := rows.Scan(
			&i.ID,
			&i.WorkflowID,
			&i.StepID,
			&i.IsActive,
			&i.Strategy,
			&i.Expression,
			&i.TenantID,
			&i.MaxConcurrency,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const runCancelInProgress = `-- name: RunCancelInProgress :many
WITH slots AS (
    SELECT 
        task_id,
        task_inserted_at,
        task_retry_count,
        tenant_id,
        strategy_id,
        key,
        is_filled,
        -- Order slots by rn desc, seqnum desc to ensure that the most recent tasks will be run
        row_number() OVER (PARTITION BY key ORDER BY task_id DESC, task_inserted_at DESC) AS rn,
        row_number() OVER (ORDER BY task_id DESC, task_inserted_at DESC) AS seqnum
    FROM    
        v2_concurrency_slot
    WHERE
        tenant_id = $1::uuid AND
        strategy_id = $2::bigint
), eligible_running_slots AS (
    SELECT
        task_id,
        task_inserted_at,
        task_retry_count,
        tenant_id,
        strategy_id,
        key,
        is_filled,
        rn,
        seqnum
    FROM
        slots
    WHERE
        rn <= $3::int
), slots_to_cancel AS (
    SELECT
        task_id, task_inserted_at, task_retry_count, tenant_id, workflow_id, strategy_id, key, is_filled, next_strategy_ids, next_keys, queue_to_notify, schedule_timeout_at
    FROM
        v2_concurrency_slot
    WHERE
        tenant_id = $1::uuid AND
        strategy_id = $2::bigint AND
        (task_inserted_at, task_id, task_retry_count) NOT IN (
            SELECT
                ers.task_inserted_at,
                ers.task_id,
                ers.task_retry_count
            FROM
                eligible_running_slots ers
        )
    ORDER BY
        task_id ASC, task_inserted_at ASC
    FOR UPDATE
), slots_to_run AS (
    SELECT
        task_id, task_inserted_at, task_retry_count, tenant_id, workflow_id, strategy_id, key, is_filled, next_strategy_ids, next_keys, queue_to_notify, schedule_timeout_at
    FROM
        v2_concurrency_slot
    WHERE 
        (task_inserted_at, task_id, task_retry_count, tenant_id, strategy_id) IN (
            SELECT
                ers.task_inserted_at,
                ers.task_id,
                ers.task_retry_count,
                ers.tenant_id,
                ers.strategy_id
            FROM
                eligible_running_slots ers
            ORDER BY
                rn, seqnum
        )
    ORDER BY
        task_id ASC, task_inserted_at ASC
    FOR UPDATE
), updated_slots AS (
    UPDATE
        v2_concurrency_slot
    SET
        is_filled = TRUE
    FROM
        slots_to_run
    WHERE
        v2_concurrency_slot.task_id = slots_to_run.task_id AND
        v2_concurrency_slot.task_inserted_at = slots_to_run.task_inserted_at AND
        v2_concurrency_slot.task_retry_count = slots_to_run.task_retry_count AND
        v2_concurrency_slot.key = slots_to_run.key AND
        v2_concurrency_slot.is_filled = FALSE
    RETURNING
        v2_concurrency_slot.task_id, v2_concurrency_slot.task_inserted_at, v2_concurrency_slot.task_retry_count, v2_concurrency_slot.tenant_id, v2_concurrency_slot.workflow_id, v2_concurrency_slot.strategy_id, v2_concurrency_slot.key, v2_concurrency_slot.is_filled, v2_concurrency_slot.next_strategy_ids, v2_concurrency_slot.next_keys, v2_concurrency_slot.queue_to_notify, v2_concurrency_slot.schedule_timeout_at
), deleted_slots AS (
    DELETE FROM
        v2_concurrency_slot
    WHERE
        (task_inserted_at, task_id, task_retry_count) IN (
            SELECT
                c.task_inserted_at,
                c.task_id,
                c.task_retry_count
            FROM
                slots_to_cancel c
        )
)
SELECT
    task_id, task_inserted_at, task_retry_count, tenant_id, workflow_id, strategy_id, key, is_filled, next_strategy_ids, next_keys, queue_to_notify, schedule_timeout_at,
    'CANCELLED' AS "operation"
FROM    
    slots_to_cancel
UNION ALL
SELECT
    task_id, task_inserted_at, task_retry_count, tenant_id, workflow_id, strategy_id, key, is_filled, next_strategy_ids, next_keys, queue_to_notify, schedule_timeout_at,
    'RUNNING' AS "operation"
FROM
    updated_slots
`

type RunCancelInProgressParams struct {
	Tenantid   pgtype.UUID `json:"tenantid"`
	Strategyid int64       `json:"strategyid"`
	Maxruns    int32       `json:"maxruns"`
}

type RunCancelInProgressRow struct {
	TaskID            int64              `json:"task_id"`
	TaskInsertedAt    pgtype.Timestamptz `json:"task_inserted_at"`
	TaskRetryCount    int32              `json:"task_retry_count"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	WorkflowID        pgtype.UUID        `json:"workflow_id"`
	StrategyID        int64              `json:"strategy_id"`
	Key               string             `json:"key"`
	IsFilled          bool               `json:"is_filled"`
	NextStrategyIds   []int64            `json:"next_strategy_ids"`
	NextKeys          []string           `json:"next_keys"`
	QueueToNotify     string             `json:"queue_to_notify"`
	ScheduleTimeoutAt pgtype.Timestamp   `json:"schedule_timeout_at"`
	Operation         string             `json:"operation"`
}

func (q *Queries) RunCancelInProgress(ctx context.Context, db DBTX, arg RunCancelInProgressParams) ([]*RunCancelInProgressRow, error) {
	rows, err := db.Query(ctx, runCancelInProgress, arg.Tenantid, arg.Strategyid, arg.Maxruns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RunCancelInProgressRow
	for rows.Next() {
		var i RunCancelInProgressRow
		if err := rows.Scan(
			&i.TaskID,
			&i.TaskInsertedAt,
			&i.TaskRetryCount,
			&i.TenantID,
			&i.WorkflowID,
			&i.StrategyID,
			&i.Key,
			&i.IsFilled,
			&i.NextStrategyIds,
			&i.NextKeys,
			&i.QueueToNotify,
			&i.ScheduleTimeoutAt,
			&i.Operation,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const runCancelNewest = `-- name: RunCancelNewest :many
WITH slots AS (
    SELECT 
        task_id,
        task_inserted_at,
        task_retry_count,
        tenant_id,
        strategy_id,
        key,
        is_filled,
        row_number() OVER (PARTITION BY key ORDER BY task_id ASC, task_inserted_at ASC) AS rn,
        row_number() OVER (ORDER BY task_id ASC, task_inserted_at ASC) AS seqnum
    FROM    
        v2_concurrency_slot
    WHERE
        tenant_id = $1::uuid AND
        strategy_id = $2::bigint
), eligible_running_slots AS (
    SELECT
        task_id,
        task_inserted_at,
        task_retry_count,
        tenant_id,
        strategy_id,
        key,
        is_filled,
        rn,
        seqnum
    FROM
        slots
    WHERE
        rn <= $3::int
), slots_to_cancel AS (
    SELECT
        task_id, task_inserted_at, task_retry_count, tenant_id, workflow_id, strategy_id, key, is_filled, next_strategy_ids, next_keys, queue_to_notify, schedule_timeout_at
    FROM
        v2_concurrency_slot
    WHERE
        tenant_id = $1::uuid AND
        strategy_id = $2::bigint AND
        (task_inserted_at, task_id, task_retry_count) NOT IN (
            SELECT
                ers.task_inserted_at,
                ers.task_id,
                ers.task_retry_count
            FROM
                eligible_running_slots ers
        )
    ORDER BY
        task_id ASC, task_inserted_at ASC
    FOR UPDATE
), slots_to_run AS (
    SELECT
        task_id, task_inserted_at, task_retry_count, tenant_id, workflow_id, strategy_id, key, is_filled, next_strategy_ids, next_keys, queue_to_notify, schedule_timeout_at
    FROM
        v2_concurrency_slot
    WHERE 
        (task_inserted_at, task_id, task_retry_count, tenant_id, strategy_id) IN (
            SELECT
                ers.task_inserted_at,
                ers.task_id,
                ers.task_retry_count,
                ers.tenant_id,
                ers.strategy_id
            FROM
                eligible_running_slots ers
            ORDER BY
                rn, seqnum
        )
    ORDER BY
        task_id ASC, task_inserted_at ASC
    FOR UPDATE
), updated_slots AS (
    UPDATE
        v2_concurrency_slot
    SET
        is_filled = TRUE
    FROM
        slots_to_run
    WHERE
        v2_concurrency_slot.task_id = slots_to_run.task_id AND
        v2_concurrency_slot.task_inserted_at = slots_to_run.task_inserted_at AND
        v2_concurrency_slot.task_retry_count = slots_to_run.task_retry_count AND
        v2_concurrency_slot.key = slots_to_run.key AND
        v2_concurrency_slot.is_filled = FALSE
    RETURNING
        v2_concurrency_slot.task_id, v2_concurrency_slot.task_inserted_at, v2_concurrency_slot.task_retry_count, v2_concurrency_slot.tenant_id, v2_concurrency_slot.workflow_id, v2_concurrency_slot.strategy_id, v2_concurrency_slot.key, v2_concurrency_slot.is_filled, v2_concurrency_slot.next_strategy_ids, v2_concurrency_slot.next_keys, v2_concurrency_slot.queue_to_notify, v2_concurrency_slot.schedule_timeout_at
), deleted_slots AS (
    DELETE FROM
        v2_concurrency_slot
    WHERE
        (task_inserted_at, task_id, task_retry_count) IN (
            SELECT
                c.task_inserted_at,
                c.task_id,
                c.task_retry_count
            FROM
                slots_to_cancel c
        )
)
SELECT
    task_id, task_inserted_at, task_retry_count, tenant_id, workflow_id, strategy_id, key, is_filled, next_strategy_ids, next_keys, queue_to_notify, schedule_timeout_at,
    'CANCELLED' AS "operation"
FROM    
    slots_to_cancel
UNION ALL
SELECT
    task_id, task_inserted_at, task_retry_count, tenant_id, workflow_id, strategy_id, key, is_filled, next_strategy_ids, next_keys, queue_to_notify, schedule_timeout_at,
    'RUNNING' AS "operation"
FROM
    updated_slots
`

type RunCancelNewestParams struct {
	Tenantid   pgtype.UUID `json:"tenantid"`
	Strategyid int64       `json:"strategyid"`
	Maxruns    int32       `json:"maxruns"`
}

type RunCancelNewestRow struct {
	TaskID            int64              `json:"task_id"`
	TaskInsertedAt    pgtype.Timestamptz `json:"task_inserted_at"`
	TaskRetryCount    int32              `json:"task_retry_count"`
	TenantID          pgtype.UUID        `json:"tenant_id"`
	WorkflowID        pgtype.UUID        `json:"workflow_id"`
	StrategyID        int64              `json:"strategy_id"`
	Key               string             `json:"key"`
	IsFilled          bool               `json:"is_filled"`
	NextStrategyIds   []int64            `json:"next_strategy_ids"`
	NextKeys          []string           `json:"next_keys"`
	QueueToNotify     string             `json:"queue_to_notify"`
	ScheduleTimeoutAt pgtype.Timestamp   `json:"schedule_timeout_at"`
	Operation         string             `json:"operation"`
}

func (q *Queries) RunCancelNewest(ctx context.Context, db DBTX, arg RunCancelNewestParams) ([]*RunCancelNewestRow, error) {
	rows, err := db.Query(ctx, runCancelNewest, arg.Tenantid, arg.Strategyid, arg.Maxruns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RunCancelNewestRow
	for rows.Next() {
		var i RunCancelNewestRow
		if err := rows.Scan(
			&i.TaskID,
			&i.TaskInsertedAt,
			&i.TaskRetryCount,
			&i.TenantID,
			&i.WorkflowID,
			&i.StrategyID,
			&i.Key,
			&i.IsFilled,
			&i.NextStrategyIds,
			&i.NextKeys,
			&i.QueueToNotify,
			&i.ScheduleTimeoutAt,
			&i.Operation,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const runGroupRoundRobin = `-- name: RunGroupRoundRobin :many
WITH slots AS (
    SELECT 
        task_id,
        task_inserted_at,
        task_retry_count,
        key,
        is_filled,
        row_number() OVER (PARTITION BY key ORDER BY task_id ASC, task_inserted_at ASC) AS rn,
        row_number() OVER (ORDER BY task_id ASC, task_inserted_at ASC) AS seqnum
    FROM    
        v2_concurrency_slot
    WHERE
        tenant_id = $1::uuid AND
        strategy_id = $2::bigint
), eligible_slots_per_group AS (
    SELECT
        task_id,
        task_inserted_at,
        task_retry_count,
        key,
        is_filled,
        rn,
        seqnum
    FROM
        slots
    WHERE
        rn <= $3::int
), eligible_slots AS (
    SELECT
        task_id, task_inserted_at, task_retry_count, tenant_id, workflow_id, strategy_id, key, is_filled, next_strategy_ids, next_keys, queue_to_notify, schedule_timeout_at
    FROM
        v2_concurrency_slot
    WHERE 
        (task_inserted_at, task_id, task_retry_count) IN (
            SELECT
                es.task_inserted_at,
                es.task_id,
                es.task_retry_count
            FROM
                eligible_slots_per_group es
            ORDER BY
                rn, seqnum
            LIMIT ($3::int) * (SELECT COUNT(DISTINCT key) FROM slots)
        )
        AND is_filled = FALSE
    ORDER BY
        task_inserted_at, task_id
    FOR UPDATE
)
UPDATE
    v2_concurrency_slot
SET
    is_filled = TRUE
FROM
    eligible_slots
WHERE
    v2_concurrency_slot.task_id = eligible_slots.task_id AND
    v2_concurrency_slot.task_inserted_at = eligible_slots.task_inserted_at AND
    v2_concurrency_slot.task_retry_count = eligible_slots.task_retry_count AND
    v2_concurrency_slot.key = eligible_slots.key
RETURNING 
    eligible_slots.task_id, eligible_slots.task_inserted_at, eligible_slots.task_retry_count, eligible_slots.tenant_id, eligible_slots.workflow_id, eligible_slots.strategy_id, eligible_slots.key, eligible_slots.is_filled, eligible_slots.next_strategy_ids, eligible_slots.next_keys, eligible_slots.queue_to_notify, eligible_slots.schedule_timeout_at, v2_concurrency_slot.task_id, v2_concurrency_slot.task_inserted_at, v2_concurrency_slot.task_retry_count, v2_concurrency_slot.tenant_id, v2_concurrency_slot.workflow_id, v2_concurrency_slot.strategy_id, v2_concurrency_slot.key, v2_concurrency_slot.is_filled, v2_concurrency_slot.next_strategy_ids, v2_concurrency_slot.next_keys, v2_concurrency_slot.queue_to_notify, v2_concurrency_slot.schedule_timeout_at
`

type RunGroupRoundRobinParams struct {
	Tenantid   pgtype.UUID `json:"tenantid"`
	Strategyid int64       `json:"strategyid"`
	Maxruns    int32       `json:"maxruns"`
}

type RunGroupRoundRobinRow struct {
	TaskID              int64              `json:"task_id"`
	TaskInsertedAt      pgtype.Timestamptz `json:"task_inserted_at"`
	TaskRetryCount      int32              `json:"task_retry_count"`
	TenantID            pgtype.UUID        `json:"tenant_id"`
	WorkflowID          pgtype.UUID        `json:"workflow_id"`
	StrategyID          int64              `json:"strategy_id"`
	Key                 string             `json:"key"`
	IsFilled            bool               `json:"is_filled"`
	NextStrategyIds     []int64            `json:"next_strategy_ids"`
	NextKeys            []string           `json:"next_keys"`
	QueueToNotify       string             `json:"queue_to_notify"`
	ScheduleTimeoutAt   pgtype.Timestamp   `json:"schedule_timeout_at"`
	TaskID_2            int64              `json:"task_id_2"`
	TaskInsertedAt_2    pgtype.Timestamptz `json:"task_inserted_at_2"`
	TaskRetryCount_2    int32              `json:"task_retry_count_2"`
	TenantID_2          pgtype.UUID        `json:"tenant_id_2"`
	WorkflowID_2        pgtype.UUID        `json:"workflow_id_2"`
	StrategyID_2        int64              `json:"strategy_id_2"`
	Key_2               string             `json:"key_2"`
	IsFilled_2          bool               `json:"is_filled_2"`
	NextStrategyIds_2   []int64            `json:"next_strategy_ids_2"`
	NextKeys_2          []string           `json:"next_keys_2"`
	QueueToNotify_2     string             `json:"queue_to_notify_2"`
	ScheduleTimeoutAt_2 pgtype.Timestamp   `json:"schedule_timeout_at_2"`
}

func (q *Queries) RunGroupRoundRobin(ctx context.Context, db DBTX, arg RunGroupRoundRobinParams) ([]*RunGroupRoundRobinRow, error) {
	rows, err := db.Query(ctx, runGroupRoundRobin, arg.Tenantid, arg.Strategyid, arg.Maxruns)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*RunGroupRoundRobinRow
	for rows.Next() {
		var i RunGroupRoundRobinRow
		if err := rows.Scan(
			&i.TaskID,
			&i.TaskInsertedAt,
			&i.TaskRetryCount,
			&i.TenantID,
			&i.WorkflowID,
			&i.StrategyID,
			&i.Key,
			&i.IsFilled,
			&i.NextStrategyIds,
			&i.NextKeys,
			&i.QueueToNotify,
			&i.ScheduleTimeoutAt,
			&i.TaskID_2,
			&i.TaskInsertedAt_2,
			&i.TaskRetryCount_2,
			&i.TenantID_2,
			&i.WorkflowID_2,
			&i.StrategyID_2,
			&i.Key_2,
			&i.IsFilled_2,
			&i.NextStrategyIds_2,
			&i.NextKeys_2,
			&i.QueueToNotify_2,
			&i.ScheduleTimeoutAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
